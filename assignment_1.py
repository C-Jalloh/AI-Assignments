# -*- coding: utf-8 -*-
"""Assignment 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pZr_fY6ZoD9EV0eiNumUcP0nadWsU8w4

#ASSIGNMENT 1

##_Task 1: Employee Data Management_

###1. *Create Variables*
"""

employee_names = ["Alice", "Bob", "Charlie", "Ebrima"]
employee_salaries = {
    "Alice": 70000,
    "Bob": 65000,
    "Charlie": 60000,
  "Ebrima": 1000000
}

"""2. Function: _Add Employee_"""

def add_employee(name, salary):
    """Adds a new employee to the employee records.

    Args:
        name: The name of the employee to add.
        salary: The salary of the employee.
    """
    employee_names.append(name)  # Add the employee's name to the list of employee names
    employee_salaries[name] = salary  # Add the employee's name and salary to the salary dictionary

"""3. _Function: Remove Employee_"""

def remove_employee(name):
    """Removes an employee from the employee records.

    Args:
        name: The name of the employee to remove.
    """
    if name in employee_names:
        employee_names.remove(name)  # Remove employee from the names list
        del employee_salaries[name]  # Remove employee and their salary from the dictionary
    else:
        print(f"Employee {name} not found.")  # Print message if employee not found

"""4. Function: _Update Salary_"""

def update_salary(name, new_salary):
    """Updates the salary of an existing employee.

    Args:
        name: The name of the employee whose salary needs to be updated.
        new_salary: The new salary for the employee.
    """
    if name in employee_names:
        employee_salaries[name] = new_salary  # Update the employee's salary in the dictionary
    else:
        print(f"Employee {name} not found.")  # Print a message if the employee is not found

"""5. Function: _Calculate Average Salary_"""

def average_salary():
    """Calculates the average salary of all employees.

    Returns:
        The average salary of all employees.
    """
    total_salary = sum(employee_salaries.values())  # Calculate the total salary of all employees
    average_salary = total_salary / len(employee_names)  # Calculate the average salary
    return average_salary  # Return the average salary

"""## **TESTS**
###_Task 1_
"""

# prompt: create a test for the functions above

# Test add_employee
add_employee("David", 75000)
assert "David" in employee_names
assert employee_salaries["David"] == 75000
print("Test add_employee")
print(employee_names)
print(employee_salaries)

# Test remove_employee
remove_employee("Bob")
assert "Bob" not in employee_names
assert "Bob" not in employee_salaries
print("Test remove_employee")
print(employee_names)
print(employee_salaries)

# Test update_salary
update_salary("Alice", 80000)
assert employee_salaries["Alice"] == 80000
print("Test update_salary")
print(employee_names)
print(employee_salaries)

# Test average_salary
avg_salary = average_salary()
assert avg_salary == (employee_salaries["Alice"] + employee_salaries["Charlie"] + employee_salaries["David"]+ employee_salaries["Ebrima"]) / len(employee_names)
print("Test average_salary")
print(avg_salary)

print("All tests passed!")

"""##Task 2: Nested Data Structure - Department Budget

1. _Create Nested Dictionary_
"""

departments = {
    "HR": {
        "budget": 200000,
        "employees": ["Alice", "David"]
    },
    "Engineering": {
        "budget": 300000,
        "employees": ["Bob"]
    },
    "Finance": {
        "budget": 150000,
        "employees": ["Charlie"]
    }
}

"""2. _Function: Add Department_"""

def add_department(department_name, budget):
    """Adds a new department to the department's dictionary.

    Args:
        department_name: The name of the department to add.
        budget: The initial budget for the department.
    """
    departments[department_name] = {"budget": budget, "employees": []}  # Add the new department with its budget and an empty employee list

"""3. Function: _Add Employee to Department_"""

def assign_employee_to_department(emp_name, dept_name):
  """Assigns an employee to a specific department.

  Args:
      emp_name: The name of the employee to assign.
      dept_name: The name of the department to assign the employee to.
  """
  if dept_name in departments:
      departments[dept_name]["employees"].append(emp_name)  # Add the employee to the department's employee list
  else:
      print(f"Department {dept_name} not found.")  # Print a message if the department is not found

"""4. Function: _Department Budget Remaining_"""

def remaining_budget(dept_name):
    """Calculates and returns the remaining budget for a department.

    Args:
        dept_name: The name of the department.

    Returns:
        The remaining budget for the department.
        Returns an error message if the department does not exist.
    """
    if dept_name not in departments:
        return "Department not found"  # Return an error message

    dept_budget = departments[dept_name]["budget"]
    total_salaries = 0
    for employee in departments[dept_name]["employees"]:
        if employee in employee_salaries:  # Check if employee exists in salary dict
            total_salaries += employee_salaries[employee]

    remaining = dept_budget - total_salaries
    return remaining

"""## **TESTS**
###_Task 2_
"""

# prompt: create a test for the above functions in tas 2

# Test add_department
add_department("Sales", 250000)
assert "Sales" in departments
assert departments["Sales"]["budget"] == 250000
print("Test add_department")
print(departments)

# Test assign_employee_to_department
assign_employee_to_department("Ebrima", "Sales")
assert "Ebrima" in departments["Sales"]["employees"]
print("Test assign_employee_to_department")
print(departments)

# Test remaining_budget
remaining = remaining_budget("HR")
assert remaining == departments["HR"]["budget"] - (employee_salaries["Alice"] + employee_salaries["David"])
print("Test remaining_budget")
print(remaining)

remaining = remaining_budget("Sales")
assert remaining == departments["Sales"]["budget"] - employee_salaries["Ebrima"]
print(remaining)

print("All tests passed!")

"""##Task 3: Variable Scope Challenge

1. _Global vs Local Variables_
"""

def scope_test():
    x = 10  # Local variable
    print("Inside function:", x)

x = 20  # Global variable
scope_test()
print("Outside function:", x)

"""##Extra Credit

_Sorting Employees by Salary_
"""

def sort_employees_by_salary():
    """Sorts employees in descending order based on their salaries.

    Returns:
        A list of employee names sorted by salary in descending order.
    """
    sorted_employees = sorted(employee_salaries.items(), key=lambda item: item[1], reverse=True)
    return [employee[0] for employee in sorted_employees]

"""This line of code is sorting the employees based on their salaries in descending order. Here's a breakdown:

`employee_salaries.items()`: This part gets the key-value pairs *(employee name and salary) *from the employee_salaries dictionary and returns them as a list of tuples. For example: *`[('Alice', 80000), ('Charlie', 60000), ('David', 75000)].
`*

`key=lambda item: item[1]`: This is the crucial part for sorting.

`key` is an argument of the `sorted()` function that specifies a function to be called on each element of the iterable *(in this case, the list of tuples)*.

`lambda item: item[1] `is an anonymous function *(lambda function)* that takes one argument `item `*(which represents a tuple like `('Alice', 80000)`)* and returns the second element of the tuple *(the salary)*.

In simpler words, this part tells `sorted()` to use the *salary (item[1])* as the basis for comparing elements.

`reverse=True`: This argument tells `sorted()` to sort in descending order *(highest salary first)*. If *`reverse=False` or omitted*, the sorting would be in ascending order *(lowest salary first)*.

In summary, this line of code takes the employee salaries, uses the salary as the key for sorting, and sorts them in descending order. The result is a list of tuples, where each tuple represents an employee and their salary, sorted from highest to lowest salary.
"""

sort_employees_by_salary()